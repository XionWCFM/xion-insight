# 왜 마이크로프론트엔드 아키텍처가 필요할까?

이부분에서 재미있던 키워드가 있는데 

POC (Proof of Concept) 소규모개념 증명

CGI (Common Gateway Interface) 

SSI (Server Side Includes) 

세가지 키워드였다.

진짜 둘다 듣도보도 못한 키워드라 흥미로웠기에 적어둔다.


<br/>

현대 웹은 발전해나가면서 프론트엔드와 백엔드로 분할하여 관리하면 유용하다는 사실을 깨달았다.

그리고 백엔드에서는 소규모 서비스를 오케스트레이션하고 결합시키는 마이크로 서비스 아키텍처가 유행하기 시작했다.

이러한 SOA(Service Oriented Architecture) 서비스 지향 아키텍처의 개념은 이전부터 있었지만 이전에는 요구사항과 제약이 많았다.

또한 잠재적으로 상호간에 의존하는 여러가지 서비스들의 오케스트레이션이 힘들다는 문제도 존재한다.

이러한 문제들의 일부분은 도커가 도입되면서 해결되었는데 도커의 경우에는 배포가 올바르게 작동할 수 있도록 격리된 컨테이너를 제공해준다.

# 마이크로 서비스의 장점

마이크로 서비스는 잘 알려진 장점 외에도 이런 장점들이 존재할 수 있다.

1. 장애는 단일 서비스와 직접 관련된다.

2. 여러 팀이 독립적으로 작업할 수 있다.

3. 배포 규모가 작아진다.

4. 프레임워크, 언어를 마음대로 선택할 수 있다.

5. 초기 출시 시간이 짧다.

6. 아키텍처의 경계가 뚜렷하다.


# 마이크로 서비스의 단점

1. 오케스트레이션 복잡성 증가

2. 다중 장애 지점

3. 디버깅, 테스트 어려워짐

4. 버전 관리 어려움

# 웹표준의 부상

코드 간의 충돌을 방지하기 위해 마이크로 프론트엔드는 상호간의 코드를 최대한 격리해야한다.

하지만 그러면서도 동시에 런타임 프레임워크 등의 리소스는 공유할 수 있어야 한다.

만약 그렇지 않는다면 최종 사용자의 리소스가 고갈될 수 있기 때문이다.


이러한 격리는 여러가지 방법을 통해 구현할 수 있는데

1. shadow dom 웹 컴포넌트

2. window.postMessage와 같은 프레임 통신

3. 웹 워커, 프록시

등을 고려할 수 있다.


# 마이크로프론트엔드의 도전 과제

## 성능

정적 웹사이트는 모든 요청을 디스크에서 페이지 읽기로 처리하는 것을 피하기 위해 인메모리 캐시를 사용한다고 한다.



## 보안

보안적인 측면에서 마이크로 프론트엔드의 양극단을 살펴보면 다음과 같다.

1. 사용자 관리를 포함한 중앙 집중시긍로 제공되는 횡단 관심사

2. 모듈이 사용자 관리에 대해 각각 책임을 지는 완전한 격리

두가지 옵션은 장단점이 있다. 보통은 바운더리 컨디션에 따라 결정한다고 하는데

중앙 사용자 관리의 경우에는 사용할 백엔드가 하나뿐일 때 적합하며

보통 많은 경우에 적합한 솔루션이 될 수 있다고 한다.


<br/>

중앙 사용자 관리에서는 중앙화된 함수를 통해서 백엔드에 모든 http 요청을 처리하거나

백엔드로 향하는 요청에 세션을 붙인 쿠키를 사용한다.

전자의 경우에는 중앙화된 함수에의해 생성된 요청에 토큰을 붙이는 것도 가능하다.

또한 사용자 관리 부분은 미들웨어를 통해서 API 요청자 부분으로부터 분리될수도 있다.


<br/>

개별 사용자 관리에서는 서드파티소스로부터 나가거나 들어오는 다수의 백엔드나 마이크로 프론트엔드가 있을 때 고려할 수 있다.

백엔드 통신을 위한 토큰을 각각의 마이크로 프론트엔드가 메모리에 가진다고 하면 백엔드에서는 같은 애플리케이션에 대해 수십개의 토큰을 생성해야한다. 

그러나 이렇게 관리하면 장점은 모든 마이크로프론트엔드가 완전히 격리되며 각각 독립성이 보장된다는 점이다.

## 스크립트 실행 

누가 마이크로프론트엔드에 기여할 수 있는지를 명확히 해야한다.

만약 누구나 기여할 수 있다면 매우 강력한 격리가 필요하다.

완전한 격리를 이루기 위해서는 iframe 혹은 worker같은 솔루션을 사용할 수 있다.


## 브라우저에서 중앙 사용자 관리를 하는 방법

1. BFF를 두는 것을 통해 백엔드에서 내부적인 쿠키를 경유하기

2. JWT 토큰을 저장하기

## 지식 공유

각 마이크로프론트엔드는 격리된 모듈이다. 따라서 다른 마이크로프론트엔드에 대한 어떤 지식도 없이 작동하는 것이 이상적이다.

하지만 현실세계에서 마이크로프론트엔드는 의존성을 띠며 다른 마이크로프론트엔드에 대한 지식이 조금 필요하다.

### 참조

강한결합을 유발하는 직접 참조와 느슨한 결합을 유발하는 간접참조 두가지로 나눌 수 있다.

모듈을 느슨하게 결합하면 변경이 쉽다는 것은 거의 상식이지만

느슨한 결합에서도 컨벤션과 컨트랙트(계약)가 존재한다. 

이때 식별자에 대한 합의를 지식 공유(knowledge sharing)이라고 부르낟.

## 신뢰성

마이크로프론트엔드는 다양한 소스에서 작은 모듈을 여러개 가져온다.

모든 요청은 실패할 가능성이 있고 일부 모듈이 실패할 확률은 더욱 높다.

따라서 신뢰성을 보장하기 위해 노력을 기울여야한다.

## 사용자 경험

최종사용자는 앱이 마이크로프론트엔드로 구성되었든 뭘로 구성되었든 단일한 단위로 보여야한다.

이것에는 작동 방식과 워딩도 포함되는 개념이다.

