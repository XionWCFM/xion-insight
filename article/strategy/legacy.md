# 레거시 코드 활용

소프트웨어의 변경에 있어서 기존의 동작을 그대로 유지한다는 것은 코드를 그대로 두는 것 이상의 의미를 가집니다.

안전한 변경을 수행하기 위해서는 영향이 미치는 범위를 정확히 이해하는 것이 필요합니다.

1. 어떤 변경을 해야하는가?

2. 변경이 정확하게 이루어졌는지 어떻게 확인할 수 있는가?

3. 무언가를 손상시키지 않았는지 어떻게 확인할 수 있는가?

저또한 버그나 성능이슈를 유발할 수 있는 레거시 코드를 건드리게되는 경우 가장 많이 걱정되는 것은

코드를 건드렸을때 이 변경이 무언가를 손상시키지 않았는지를 확인할 방법이 있는가입니다.

저같은 경우에는 해피케이스와 더불어 예상가능한 엣지케이스를 실제로 테스트해보고 큰 문제가 없으면 커밋하는 편인데요

그럼에도 불구하고 실제 프로덕션에서는 버그가 발생하기도 합니다.

애플리케이션의 무결성이 매우 중요시되는 경우에는 어떻게 해야할지는 한번 생각해봐야할 것 같네요

<br/>

# 레거시 딜레마

레거시 코드는 딜레마가 존재합니다.

코드를 안전하게 변경하기 위해서는 테스트 코드를 통해 변경되었어도 기능이 깨지지 않는다는 것을 확인하는 게 좋습니다.

그러나 테스트 코드를 배치하기 위해서는 레거시 코드 자체를 변경해야하는 경우가 잦습니다.

레거시는 아름다운 형태로 짜여지지 않은 경우가 많기 때문에 환경, 외부코드에 강하게 의존하고있는 경우가 많기 때문입니다.

이러한 경우 본 아티클에서는 이런 형태로 변경할 것을 권합니다.

1. 변경 지점을 식별한다.

2. 테스트 코드를 작성할 위치를 찾는다

3. 의존 관계를 제거한다

4. 테스트 코드를 작성한다

5. 리팩토링을 수행한다.

그런데 사실 이 경우 "의존관계를 제거한다" 부분에서 수많은 불안사항이 생기기 쉽습니다.

저 같은 경우에는 실제로 애플리케이션을 실행시켜보면서 테스트하고 그 뒤에 테스트 코드를 작성하는 식으로 대처하는데요

시간이 상당히 많이 드는 작업이기 떄문에 처음부터 테스트에이블하게 코드를 짜는게 좋은 것 같습니다

# 감지와 분리

의존 관계를 제거하는 데에는 두가지 이유가 있습니다.

1. 코드 내에서 계산된 값에 접근할 수 없을 때 값을 감지하기 위해 의존 관계를 제거하는 경우

2. 코드를 테스트에 넣어서 실행하는 게 안될 때 코드를 분리하기 위해 의존 관계를 제거하는 경우

# 봉합 모델

봉합 지점이란 코드를 직접 편집하지 않고도 프로그램의 동작을 변경할 수 있는 위치를 말합니다.

의존성을 주입받아서 실행하는 부분 그러니까 즉 DI 컨테이너 부분을 말한다고도 볼 수 있는데요

의존성을 받는 부분, 함수나 메서드의 인자로 인터페이스를 받는 부분을 활성화 지점이라고 합니다.

실제 구현을 내부에서 호출하는게 아니라 인터페이스를 받고 외부에서 구현을 받는 식으로 짜면 테스트가 쉽겠죠?

## 전처리기 봉합

바벨 등 컴파일러, 트랜스파일러를 통하여 런타임 의존성을 교체하는 방식으로 jsdom , happy-dom이 이런 방식을 채택합니다.

## 링크 봉합

테스트 환경과 제품 환경 간에 차이가 있도록 구성합니다.

이러한 지점은 소스 코드의 외부에 위치하게 되는데요 빌드 시 스크립트나 배치 스크립트에 존재하기도 합니다.

## 객체 봉합

의존성 주입을 통해 의존성을 교체하는 방식입니다.

이러한 봉합 방식 중 링크, 전처리기 봉합은 객체 봉합이 불가능할 때에만 사용하는게 권장된답니다.

# 소프트웨어를 변경할 때

## 코드가 좋은지 나쁜지 판단하는 방법

-> 한개의 책임과 관련된 코드가 얼마나 커지는지 , 나머지 코드와 얼마나 얽혀 있는지에 따라 결정된다.

## 이름을 바꾸면 코드를 바라보는 관점이 달라진다.

-> 저도 리팩토링할 때 제일 많이하는게 이름 바꾸기, 폴더위치 바꾸기인데 요것만 해줘도 많이 바뀌더라구요

## private 메서드를 테스트해야한다면 그 메서드는 public으로 만들어야한다.

-> 이때 이게 하기 싫게 느껴진다면 그 이유는 보통

1. 단순 유틸이다

2. 이게 노출되면 클래스의 다른 메서드의 결과값에 영향이 갈 우려가있다.

2번때문에 꺼려지는 경우면 애초에 모듈 자체를 수정해야할 가능성이 높다

하지만 당장 분리할 수 없다면 protected를 통해서 상속받는 클래스를 만들고 테스트를 진행한다.

## 캡슐화가 아름다운 이유

캡슐화는 코드에 대한 이해를 돕기 위한 도구이다.

따라서 캡슐화는 우리가 코드에 대해 추론하는 것을 도와준다.

캡슐화가 잘 되었다면 변경에 따른 영향을 추론할 때 적은 수의 경로만 따라가도 된다!

## 테스트의 수준

상위 수준에서의 테스트는 리팩토링할 때 유용하다.

따라서 세부 수준에서의 테스트보다 상위 수준의 테스트를 선호한다.

상위 수준 테스트는 단위 테스트를 작성하기 위한 첫 단계로 간주하자

# 리팩토링에 임할 때의 자세

1. 장기적으로는 낙관적이게 생각한다 (우린 리팩토링을 잘 해낼 수 있다!)

2. 단기적으로는 보수적이게 접근한다 (이 변경은 어려우니까 테스트부터 차근차근하자)

3. 하나를 더 만들어서 이를 참조하게하면서 의존 관계를 제거한다(한꺼번에 다 바꾸지 말고)

4. 컴포넌트에서 훅은 두가지로 나눌 수 있다 (리소스에 접근하는 것 / 접근하면서 변경도 하는 것)

하나를 더 만들어서 의존관계를 제거하는 기법은 저도 일할 때 굉장히 많이 사용하는 방법인데요

의존하고있는 코드를 그냥 바꿔버리게되면 거기에 의존하던 또다른 레거시코드들이 깨져버리는 경우가 생기곤합니다.

그래서 하나를 더 만들고 차근차근 의존관계를 없애가는 식으로 만드는데

이런 방법을 하게되면 과도기 시점 (두 개의 비슷한일을 하는 코드가 있는 시점)에서 개발자로서의 불편함이 생기는 단점이 있긴합니다.

# 레거시를 대하는 자세

레거시 시스템에서는 "어떻게 동작해야 하는지" 보다 "실제로 어떻게 동작하고 있는지"가 더 중요합니다.

따라서 변경 작업을 명확하게 하기 위한 테스트 코드를 정확한 위치에 작성하는 것을 목표로하며

문서화 테스트를 작성합니다.

- 문서화 테스트란?

1. 기존 동작 유지에 필요한 테스트이며 시스템의 현재 동작을 그대로 문서화 한 것입니다

2. 코드의 실제 동작을 기록하는 테스트이며 동작이 버그일지라도 기록합니다.

# 마치며

솔직히 레거시는 피할 수 있는 것이 아니라고 생각합니다.

따라서 우리는 레거시를 잘 활용하고 잘 청산할 방법을 고민하는게 좋지 않을까요?

# 레퍼런스

https://tosspayments-dev.oopy.io/66bd4494-792a-4137-82bc-57eb41f32345
