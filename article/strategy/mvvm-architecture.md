# MVC 아키텍처

MVC 아키텍처는 고전적이고 기본적인 아키텍처 중 하나입니다.

Model, View , Controller 세가지로 영역을 나누면

애플리케이션을 관리하기 좋다는 관점에서 나온 개념입니다.

<br/>


# MVC를 프론트엔드의 관점에서 바라보면

## view

프론트엔드 관점에서 view는 즉 화면을 의미하게됩니다.

일반적으로는 HTML, CSS로 만들어지는 화면을 의미하죠!

## model

화면의 어딘가에는 실제 데이터가 반영되어 나타나야 합니다.

이 `데이터`를 주관하는 영역을 Model이라고 부를 수 있어요

이 모델은 자바스크립트의 객체일수도 / 서버의 api 데이터일수도 / 서버에 있는 DB일수도 있습니다.

아키텍처에 따라 무엇이 모델인지는 달라질 수 있어요!

## controller

앞서 살펴보았듯 데이터는 화면에 그려져야 그 의미가 있습니다.

그리고 만약 데이터가 변경된다면 화면도 데이터의 변화에 맞추어 같이 변화해야겠지요?

따라서 데이터가 변하면 화면도 변하게 만들어줄.

데이터와 화면을 동기화시켜주는 일을 수행할 객체가 필요합니다.

<br/>

컨트롤러는 Model의 데이터를 받아서 View를 그리고

View에서 일어난 사용자 상호작용 이벤트를 수신해서 그에 맞게 Model의 데이터를 변경시키는 일을 수행합니다.

즉 Model과 View 둘 사이를 잘 이어주는 역할을 수행하는 것이 컨트롤러라고 볼 수 있습니다.


## 왜 MVC 패턴을 쓸까요?

관심사를 분리하는 것이 소프트웨어를 관리하는 것을 용이하게 만들어주며

잘 격리된 관심사들은 문제가 발생했을때 찾아보아야할 영역을 좁혀줍니다.

화면을 다루는 문제와 데이터를 다루는 문제는 그 성격이 다르기 때문에 분리할 수 있고

Model과 View가 서로 강결합(직접적으로 의존하는 관계)가 되지 않도록 하여

화면 수정이 데이터 수정에 직접적인 영향을 미치지 않고

데이터 수정이 화면 수정에 직접적인 영향을 끼치지 않도록 하기 위해

그 중간에서 데이터와 화면을 느슨하게 이어주는 컨트롤러를 두는 것이 MVC 패턴이라고 할 수 있습니다.


# MVVM 아키텍처

그런데 프론트엔드에서 MVC 패턴을 적용하여 개발하다보니 불편한 점이 생깁니다.

모델 뷰를 분리해놓고 개발을 하다보니 피곤하고 반복적인 패턴들이 발생하는 것이지요

기존 바닐라 자바스크립트 / JQuery를 이용하던 경우에는 개발자가 직접 DOM API들을 이용하여

데이터와 화면을 동기화 시키는 작업을 수행해야했습니다.

그리고 구글은 2013년에 발표한 앵귤러라는 프레임워크는 이 불편함을

템플릿, 바인딩이라는 개념들을 통하여 선언적으로 관리하는 방식으로 해소합니다.

<br/>

이제 프론트엔드에서는 DOM을 조작하는 코드를 작성하지 않습니다.

대신 그런 지루한 작업들은 프레임워크들이 담당하는 것이지요!

개발자는 이제 화면에 그려질 데이터와 화면에 집중하고 이 둘을 동기화 시킬 방법은 프레임워크에게 위임합니다.

**그리고 이것을 View를 그리는 Model 만 다루게 되었다는 의미에서 ViewModel이라고 부르게 됩니다.**

이것이 MVVM , Model / view / viewModel 아키텍처인것이지요

# MVC와 MVVM의 차이점

데이터 바인딩의 개념이 가장 중요합니다.

MVVM 아키텍처는 뷰는 뷰모델과 통신하지만 뷰모델은 뷰와 직접적으로 통신하지 않습니다.

간접적으로 뷰에게 결과를 전달하지요

이 방법의 장점은 뷰모델이 더이상 뷰가 어떤 구조를 가졌는지 신경쓰지 않아도 된다는 것입니다.

그리고 이 MVVM 아키텍처를 만들 수 있는 것은 데이터바인딩 개념 덕분이라는 것이죠!

# MVVM의 처리 순서

1. 사용자의 상호작용이 View에 전달된다.

2. View는 ViewModel에게 사용자 이벤트 / 데이터를 전달한다.

3. ViewModel은 받은 정보를 로직에 따라 처리하여 Model을 업데이트한다.

4. 갱신된 데이터를 구독(데이터 바인딩, 옵저빙) 등을 하고 있는 ViewModel이 업데이트된다.

5. 해당 ViewModel의 데이터를 구독하고 있는 View가 업데이트 된다.


# 왜 MVVM 패턴을 쓸까?

기존 MVC 패턴에서는 view와 model의 의존성이 높았으며 컨트롤러가 비대해지기 쉬웠습니다.

컨트롤러로 그 둘을 분리한다하더라도 View에서 일어난 상호작용이 

또한 데이터 바인딩을 하지 않다보니 동기화 문제가 발생하기 쉬웠어요


# 그럼 리액트는 mvc 인가요? mvvm 인가요?

mvc, mvvm 패턴은 사람이 이해하기 쉽도록 만든 개념입니다.

따라서 실제 애플리케이션 개발에 100% 부합하는 경우를 찾는것은 쉽지 않습니다.

리액트 역시도 마찬가지로 정확히 어떤 패턴이다라고 표현하기엔 어려움이 있습니다.

예컨대 MVVM 패턴의 가장 큰 특징은 view와 viewmodel 간의 양방향 데이터 바인딩입니다.

즉 view 와 viewmodel 중 하나의 변경 사항은 명시적 업데이트 없이 다른 항목에 자동으로 반영된다는 것입니다.

그러나 리액트는 알다시피 단방향 데이터 바인딩을 사용하며 동작을 MVVM에 비유하여 생각할 수는 있지만

라이브러리 차원에서 MVVM 패턴을 따른다라고 보기는 어렵습니다.


# 리액트의 단방향 데이터 바인딩

리액트는 Model -> View의 방향 즉 자바스크립트 -> HTML의 방향으로만 데이터를 동기화합니다.

그렇기 때문에 HTML -> 자바스크립트로의 직접적인 데이터 갱신은 불가능하다는 제약이 존재합니다.

또한 리액트는 컴포넌트 간의 데이터흐름에도 단방향 데이터 바인딩을 이용합니다.

상위 컴포넌트에서 하위 컴포넌트로 데이터를 넘겨주는 것은 가능하지만 그 반대는 불가능하지요

그렇기 때문에 리액트는 서로 다른 컴포넌트에서 데이터를 공유하고 변경하며 사용하기 위해서는

둘 사이에 공통된 부모 컴포넌트를 두고 상태 끌어올리기 등의 패턴을 이용해 간접적으로 데이터를 하위에서 변경하게 됩니다. 

<br/>

반면 양방향 데이터바인딩을 따르는 프레임워크에서는

상태 끌어올리기 패턴 대신 자식 컴포넌트에서 emit event를 통해 부모 컴포넌트에게 데이터를 전달합니다.


# 마치며

글을 읽으며 많은 혼란이 생기셨을거라고 생각합니다.

제가 부족한 탓도 있겠지만 제가 겪었던 가장 큰 혼란의 이유를 설명드리자면

양방향, 단방향 데이터 바인딩이라는 용어가 혼용되고 있기 때문입니다.


모델 - 뷰 간의 데이터 바인딩

부모 - 자식 간의 데이터 바인딩

두 가지 영역에서 데이터 바인딩이라는 용어가 혼용되고 있기 떄문입니다.

<br/>

마찬가지로 본 글에서도 모델 - 뷰 / 부모 - 자식 두가지 관점을

사전에 설명하지 않고 혼용하여 설명하느라 혼란이 발생하셨을 것 같기도하네요

# 레퍼런스

https://velog.io/@teo/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C%EC%97%90%EC%84%9C-MV-%EC%95%84%ED%82%A4%ED%85%8D%EC%B3%90%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80%EC%9A%94

https://bestalign.github.io/translation/cartoon-guide-to-flux/

https://ykss.netlify.app/web/design_pattern/

https://gusrb3164.github.io/web/2021/03/09/mvc-mvp-mvvm-structure/

https://adjh54.tistory.com/49