# 모듈을 어떻게 읽는 걸까요?

```tsx
import FAS from '@/src/frontend-article-study';
```

자바스크립트 개발자라면 필연적으로 모듈을 사용합니다.

사실 개발자라면 모듈을 사용한다고 해도 과언이 아닐정도로

모듈은 소프트웨어 개발에 날개를 달아주는 개념입니다.

그런데 그럼에도 불구하고 모듈이 어떻게 동작하는지에 대한 고민은 적은 것 같습니다.

이번에는 어떻게 자바스크립트에서 모듈을 읽어오는지를 다룹니다.

# 모듈이란 ?

모듈의 개념이 도입되기 이전 자바스크립트를 이용하는 개발자는 코드를 전역 네임스페이스에 넣거나

IIFE로 감싸는 것을 통해 함수스코프로 네임스페이스를 제한하는 식의 코딩을 하곤 했습니다.

그러나 프로젝트의 규모가 커지게되면 이름 충돌 , 너무 큰 번들크기 등 여러가지 문제에 직면하게됩니다.

이러한 문제로 인해 CJS , AMD와 같은 모듈 솔루션이 등장하지만 서로 호환되지 않는 솔루션들은 사용자를 더욱 괴롭게 만들었습니다.

이런 문제를 위해 자바스크립트는 ES2015에서 모듈을 표준화하며 ESM 모듈을 사양에 추가하였습니다.

또한 모듈을 간략하게 정의하면 "자체 컴파일 단위를 가지고 있는 코드의 단위"라고 정의할 수 있다는 점까지 기억하고 가겠습니다.


# 리빙포인트

```html
    <script type="module" src="./hi.js">
```

다음과 같이 모듈인 자바스크립트 태그는 HTML의 구문분석을 지연시키지 않으며 병렬로 로드됩니다.

쉽게 생각하면 defer 속성이 있는 스크립트 태그와 동작이다. 라고 생각해도 좋습니다.


그런데 defer의 동작 방식을 생각하면 조금 의아한 점이 생깁니다.

만약 모듈의 의존관계가 동적으로 변할 수 있다면 스크립트를 실행시켜봐야지만 의존하고있는 모듈을 명확히 할 수 있지않을까요?

그런 모순을 이기기 위해 모듈은 정적으로 분석할 수 있는 형태로 설계되었습니다.



# 자바스크립트는 어떻게 모듈을 읽을까?

1. 임포트와 구문 분석

모듈의 소스 텍스트를 임포트하고 구문 분석을 통해 임포트 및 익스포트를 결정합니다.

<br/>

앞서 모듈 스크립트는 html 파서를 멈추게하지 않는다고 하였던거 기억하시죠?

defer처럼 동작하는 모듈스크립트는 async 옵션을 주지 않았따면 html 파서가 완료된 이후에 동작합니다.

브라우저가 스크립트 태그의 js 파일 내용을 자바스크립트 엔진에 전달하면

엔진은 이 자바스크립트파일을 구문 분석하고 그에 대한 "모듈 레코드"를 생성합니다.

모듈레코드에는 구문 분석된 코드와 이 모듈이 필요한 또다른 모듈의 목록 그리고

임포트 엔트리 , 익스포트엔트리 , 모듈 상태가 포함됩니다.

(임포트 엔트리 ,익스포트 엔트리, 모듈 상태는 분량상 다루지않겠습니다.)

<br/>

이렇게 자바스크립트 엔진은 모듈 레코드를 생성한 뒤 호스트에 반환하며

호스트는 모듈 지정자 아래의 확인된 모듈 맵에 저장합니다.

(http://localhost3000에서 html 파일이 왔다면 http://localhost3000/모듈.js) 와 같은 형식을 모듈 맵이라고 합니다.

이렇게 모듈 맵에 모듈레코드를 잘 저장하고 난 뒤 부터는

나중에 모듈 레코드가 필요할 때에 자바스크립트 엔진은 호스트에게 모듈을 요청합니다.

그리고 호스트는 모듈 맵에서 모듈 레코드를 찾아보고 발견하면 반환하는 식이지요



2. 인스턴스화

모든 임포트 및 익스포트에 대한 바인딩을 포함하여서 모듈의 환경 및 바인딩을 생성합니다.

인스턴스화 단계에서는 위 문장으로 설명한 바와 같이 모든 임포트 , 익스포트에 대한 바인딩을 포함해서 각 모듈의 환경 객체와 그 안에 최상위 바인딩을 만듭니다. 

이러한 인스턴스화는 "최하위 모듈"이 가장 먼저 인스턴스화 될 수 있도록 깊이 우선 탐색(DFS)를 통하여 수행됩니다.

<br/>

조금 더 세부적으로 봐볼까요?

1 시점에서 자바스크립트 파일이 구문 분석 되었기 때문에 자바스크립트 엔진은 해당 파일에 대한 인스턴스화 단계를 시작합니다.

인스턴스화를 위해 가장 먼저 하게되는 일은 해당 파일이 임포트하는 모듈이 모듈맵에 존재하는지 확인하는 일입니다.

앞선 단계에서 수행한 작업 덕분에 자바스크립트 엔진은 모듈레코드의 정보를 이용해서 인스턴스화와 평가해야하는 모듈 트리를 결정할 수 있습니다.

이렇게 인스턴스화 된 모듈은 "코드 평가 단계"는 마쳤지만 코드가 실행되지는 않은 상태가 됩니다.

즉 호이스팅 될 수 있는 것들은 호이스팅 된 상태이지만 아직 코드가 실행되지는 않은 상태라는것입니다.

let, const로 선언된 변수의 경우에는 TDZ에 빠진 상태가 됩니다.


3. 평가

이렇게 인스턴스까지 마치고나면 자바스크립트 엔진은 모듈의 최상위 코드를 다시 DFS로 실행하여 각 모듈을 "평가됨"으로 표시합니다.




자바스크립트의 모듈 시스템은 이러한 세단계를 거쳐 실행된다고 정의할 수 있습니다.



# 근데 그럼 동적임포트는 뭔가요?

모듈 시스템은 정적으로 분석가능해야한다는 설계상 의도로 인하여

모듈 지정자는 항상 문자열 리터럴이어야하며 정적으로 분석가능해야했습니다.

하지만 일부 사용 사례의 경우 동적으로 런타임에 가져올 모듈을 결정해야하는 경우가 있죠

이런 사용사례를 위하여 ES2020에서 동적 임포트 구문이 추가되었습니다.

<br/>

그럼 동적 임포트는 어떻게 평가를 거치게 되는걸까요?

저는 동적 임포트의 경우 lazy하게 평가되며 평가시점에 위에서 서술한 모듈 평가 과정을 거친다고 생각하지만

제가 잘못 이해한 것일수도 아닐 수도 있습니다.

혹시 아시는 분은 알려주세요


# 마치며

모듈의 세계는 심오하네요..