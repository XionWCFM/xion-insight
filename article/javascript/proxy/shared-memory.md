# 공유 메모리 기능 (ES2017+)

흔히 자바스크립트는 단일 스레드 언어이다. 라고 많이 표현하지만

사실 현대의 개발 환경에서 자바스크립트는 단일 스레드 언어가 아닙니다 (웹 워커 덕분에)

그러나 그럼에도 불구하고 자바스크립트는 브라우저의 스레드 간에 메모리를 공유할 방법이 없었습니다.

초기에는 스레드가 데이터가 포함된 메시지를 서로 게시할 수 있었지만 데이터는 "복사" 되었습니다.
흠
즉 데이터 자체가 크거나 데이터를 많이 보내야하는 경우 그만큼 복사라는 것이 가지는 의미가 커졌습니다.

<br/>

그리고 세월이 흘러 ES2015에서 Typed Array가 추가된 이후에는 데이터를 복사하지 않아도

한 스레드에서 다른 스레드로 데이터를 전송할 수 있게 되었지만 보내는 스레드는 전송 되는 데이터에 대한 접근을 포기해야했죠

ES2017에서는 SharedArrayBuffer를 통해 한 스레드에서 실행되는 자바스크립트 코드를 다른 스레드에서 실행되는 자바스크립트 코드와 메모리를 공유할 수 있어졌습니다.

# 개쩌네요 당장 쓰죠

라고 생각하기 이전에 우리는 왜 자바스크립트가 단일 스레드 언어로 설계 되었는지 고민해볼 필요성이 있습니다.

단일 스레드를 채택함으로서 얻을 수 있는 가장 큰 장점은 프로그래밍하기 쉬워진다는 것입니다.

멀티 스레드 환경에서 프로그래머는 여러가지 동기화 문제, 자원 우선순위 문제 등에 시달리게됩니다.

그러니 우리는 공유메모리를 사용하기 이전에 "꼭 공유 메모리가 아니면 해결할 수 없는 문제인가?"를 먼저 고려해야해요

# 트랜스퍼러블

보통 우리는 공유메모리를 써야만 하는 일이 없습니다.

"엥?? 이럴땐 공유메모리가 좋지않을까요??" 싶은 순간에도 대부분 필요가 없습니다.

그 이유는 앞서 살짝 다루었지만 서로 다른 스레드간에 데이터를 전송할 수 있는 "트랜스퍼러블"(transferable) 덕분이에요

트랜스퍼러블을 통하여 ArrayBuffer를 포함한 다양한 객체를 전송할 수 있습니다(이미지 유형이나 캔버스까지 포함해서요!)

따라서 서로 다른 스레드 간에 주고받아야할 데이터가 있는 경우에 트랜스 퍼러블을 통해 전송하는 것으로 복사의 오버헤드를 피할 수 있습니다.

```tsx
const MB = 1024 * 1024;
let array = new Uint8Array(20 * MB);
worker.postMessage({ array }, [array.buffer]);
```

# 공유메모리 생성해보기

```tsx
const sharedBuf = new SharedArrayBuffer(5 * Uint16Array.BYTES_PER_ELEMENT);
const sharedArray = new Uint16Array(sharedBuf);
const worker = new Worker('./example-worker.js');
let counter = 0;
worker.addEventListener('message', (e) => {
  if (e.data && e.data.type === 'ping') {
    console.log('awesome');
  }
});
```
이때 SharedArrayBuffer는 크기를 엔트리가 아니라 바이트 단위로 지정하기 때문에 원하는 엔트리 수에 BYTES_PER_ELEMENT 속성을 곱하곤 합니다

즉 위 예제에서는 엔트리 5개를 가지는 버퍼를 만들기 위한 코드를 작성한것이다. 라고 생각할 수 있어요

# 재밌는 키워드

## 임계구역

임계구역이란 메모리르 공유하는 동시에 스레드가 수행하는 모든 작업과 관련하여 원자적인 방식으로 공유 메모리에 접근해야하는 스레드에서 실행되는 코드입니다.

임계구역에서 동일한 메모리를 두번 읽으면 항상 동일한 값이 나와야한답니다.

## 뮤텍스

운영체제 공부하면 단골로 나오는 내용이죠 공유 메모리에 대한 독점 접근을 제공하여 임계 구역을 보호하는 수단이라고 생각할 수 있습니다.

## 레이스 컨디션

두개 이상의 프로세스 혹은 스레드가 공유 자원을 서로 사용하려고 경합하는 현상을 의미합니다.

이처럼 멀티스레드 환경에서 자원을 공유할 수 있게되면 동기화 문제가 발생하기 쉬운데요

1. 값이 0인 변수 "eunhe"

2. 스레드 "woo" , "ah"

3. 스레드 "woo"가 eunhe를 읽어옴

4. 스레드 "ah"도 eunhe를 읽어옴

5. 스레드 "woo"가 eunhe의 값에 1을 더한값을 저장

6. 스레드 "ah"가 eunhe의 값에 2를 더한값을 저장

7. eunhe 변수의 값은?

=> 스레드 ah는 0 + 2를 하고 마지막으로 저장했으니 eunhe는 2


# 조졌내요 이거 어케 씀?

공유 메모리를 쓰게되면 이런 dog 같은 문제들에 직면하게 됩니다.

따라서 자바스크립트는 이런 문제들을 처리하기 위해 Atomics 객체를 제공하는데요

순차적 / 동기적인 방식으로 공유 메모리를 처리할 수 있게 도와주는 기능이라고 생각하시면 되겠습니다.


```ts
const sab = new SharedArrayBuffer(1024);
const ta = new Uint8Array(sab);

ta[0]; // 0
ta[0] = 5; // 5

Atomics.add(ta, 0, 12); // 5
Atomics.load(ta, 0); // 17

Atomics.and(ta, 0, 1); // 17
Atomics.load(ta, 0); // 1

Atomics.compareExchange(ta, 0, 5, 12); // 1
Atomics.load(ta, 0); // 1

Atomics.exchange(ta, 0, 12); // 1
Atomics.load(ta, 0); // 12

Atomics.isLockFree(1); // true
Atomics.isLockFree(2); // true
Atomics.isLockFree(3); // false
Atomics.isLockFree(4); // true

Atomics.or(ta, 0, 1); // 12
Atomics.load(ta, 0); // 13

Atomics.store(ta, 0, 12); // 12

Atomics.sub(ta, 0, 2); // 12
Atomics.load(ta, 0); // 10

Atomics.xor(ta, 0, 1); // 10
Atomics.load(ta, 0); // 11
```

# 결론

아마 자바스크립트의 공유메모리에 대해서는 대부분 생소하실 것이라고 생각합니다.

웬만하면 계속 생소해도 되는 일만 하는게 좋을 것 같습니다.

발표 분량 상 아주 라이트하게 쳐내고 쳐냈음에도 공유메모리 자체가 주는 폭력성이 있네요

다들 싱글스레드언어임에 감사하면서 혹시 공유메모리 필요하려나?

싶은 순간에는 postMessage를 먼저 시도해봅시다. 감사합니다.

