# 프록시 패턴 알아보기

프록시는 다른 객체에 대한 대체 또는 자리표시자를 제공할 수 있는 구조 디자인 패턴입니다.

프록시는 원래 객체에 대한 접근을 제어하기 때문에

당신의 요청이 원래 객체에 전달되기 이전에 또는 이후에 뭔가를 수행할수 있도록 해줍니다.


<br/>

이러한 프록시 패턴을 접해보고 나면 이러한 의문이 생기기 쉽죠

"왜 객체에 대한 접근을 제한하고 프록시라는 대리자를 내세우는 걸까?"

대표적으로 프록시 패턴이 유용한 경우가 몇가지 있을 수 있지만 한 경우를 생각해보겠습니다.

1. 막대한 양의 자원을 소모하는 거대한 객체가 존재한다면?

2. 근데 이 객체가 필요할 때도 있지만 항상 필요한 건 아니라면?

이런 경우 우리는 그럼 "필요할 때에만 이 객체를 만들면 되지않을까?"라고 생각할 수 있죠!

그렇다면 필요할 때에만 만들도록 지연된 초기화를 구현하면 될 것입니다.

그런데 그렇다면 이 객체를 사용하고자 하는 모든 클라이언트들은 우리가 구현한

지연된 초기화를 수행하는 코드를 실행해야할텐데

아마 코드중복이 많이 일어나겠죠...


<br/>

이런 경우에는 프록시 패턴을 통해 원래 서비스 객체와 같은 인터페이스를 지닌 프록시 클래스를 만드는 것을 이용하여 해결할 수 있습니다.

클라이언트로부터 요청을 ㅂ다으면 프록시는 실제 서비스 객체를 생성한다음 실제 작업은 서비스 객체에게 위임하는 것이지요

이런 방법을 이용하면 클라이언트들은 프록시에게 작업을 요청하지만 실제 작업은 서비스객체가 수행하며 요청과 작업 사이에 여러가지 일들을 처리할 수 있습니다.

예를 들면 결괏값을 캐싱한다든지하는 일을 말이에요




# proxy

프록시 객체는 대상 객체로 가는 도중에 기본적인 객체 작업을 가로채는 데에 사용할 수 있는 객체입니다.

프록시를 생성할 때에는 속성 값 임포트나 새 속성 정의 같이 처리할 작업에 대해 하나이상의

"트랩"에 대한 핸들러를 정의할 수 있는데요

프록시에 대해서는 다양한 사용사례가 있을 수 있습니다.

# 프록시의 사용사례

1. 객체에서 발생하는 작업 기록

2. 존재하지 않는 속성 읽기 / 쓰기를 오류로 만들기

3. 두 코드 영역 사이에 경계 제공

4. 변경 가능한 객체의 읽기 전용 뷰 만들기

5. 객체에 정보를 숨기거나 객체가 실제보다 더 많은 정보를 가지고 있는 것처럼 보이게 하기

# 선수 지식

## 트랩은 뭐고 트랩 핸들러는 뭐야?

트랩이란 프록시 객체에서 특정 작업이 수행될 때 마다 자동으로 호출되는 함수를 말합니다.

트랩 핸들러는 위에서 이야기한 트랩들을 포함하는 하나의 객체입니다.

이 핸들러 객체에는 다양한 트랩 함수들을 정의할 수 있는데

이 함수들은 원본 객체에 대한 작업들을 가로채고 사용자가 정의한 동작을 수행하게 합니다.

메타프로그래밍을 위한 기법이라고 하네요




# 간단한 예제

```tsx
const obj = {
  testing: 'abc',
};

const p = new Proxy(obj, {
  get(target, name, receiver) {
    console.log(`getting property  ${name}`);
    return Reflect.get(target, name, receiver);
  },
});
console.log(`${obj.testing}`);
console.log(`${p.testing}`);
console.log(`${p.foo}`);
```

Reflect 클래스에 대한 경험이 있다면 어렵지 않게 읽히는 코드입니다.

이 예제 코드는 get 트랩에 대한 핸들러를 정의하는 프록시를 생성하는데요

이 예제를 이해하기 위해 약간의 프록시에 대한 지식이 필요합니다.

1. 프록시를 생성할 때에는 프록시 생성자의 첫번쨰 인수에 대상이 될 객체를 넣고 두번째 인수에 "트랩핸들러"를 가지고 있는 객체를 전달해야합니다.

2. 대상 객체에서 직접 수행되는 작 업은 프록시를 트리거하지 않고 프록시를 통해 수행되는 작업만 수행합니다.

이 2번에 대해 이해할 수 있도록 console.log가 어떻게 실행되는지를 체크해보겠습니다.

```
abc
getting property  testing
abc
getting property  foo
undefined
```

프록시 객체를 거치지 않고 원본객체 obj에 접근하는 경우에는 프록시 메서드가 사용되지 않는 것을 확인할 수 있군요

3. get 트랩은 하나의 단일 속성에만 국한되지 않습니다. foo와 같이 존재하지 않는 속성에 대해서도 프록시의 모든 속성 접근이 이것을 통과합니다.


여기까지 보았을때 프록시는 기본 작업을 수신하는 것 이상을 할 수 없다고 하더라도 매우 유용하게 쓸 수 있지만 작업 결과를 변경시키거나 아니면 아예 작업 자체를 완전히 억제할 수도 있습니다.

# 프록시 객체를 이용하여 특정 작업을 수행시키기

```tsx
const obj = {
  testing: 'abc',
};

const p = new Proxy(obj, {
  get(target, name, receiver) {
    console.log(`getting property  ${name}`);
    let value = Reflect.get(target, name, receiver);
    if (value && typeof value.toUpperCase === 'function') {
      value = value.toUpperCase();
    }
    return value;
  },
});

console.log(`${obj.testing}`);
console.log(`${p.testing}`);
console.log(`${p.foo}`);

```

```
abc
getting property  testing
ABC
getting property  foo
undefined
```

흥미로운 결과입니다. 원본 객체는 전혀 수정되지 않았지만 프록시 객체를 거친 경우
리턴되는 밸류가 어퍼케이스되어 반환받게되네요

# 트랩

트랩에 대한 핸들러를 지정하지 않으면 프록시는 작업을 대상 객체에 직접 전달합니다.

따라서 위 예제에서 get 트랩만 정의한 것도 그와 같은 이유입니다.

다른 정의하지 않은 작업은 객체에 직접 전달됩니다.

apply, construct, defineProperty, deleteProperty , hase, set 등등

트랩이 가능한 것들은 여러개 있으니 필요하신 분은 표를 찾아보세용


# 트랩핸들러와 프록시가 유용한 시점

여기까지 봤을떄 제가 느낀 점은 사이드이펙트가 요구되는 경우에 유용할 수 있겠다 였는데

사용예시에도 그런 부분 위주로 추천이 많았습니다.

가장 실전적으로 많이 사용될 여지를 생각해본다면 역시 로깅 작업과 같은 부수효과일것같습니다.

<br/>

# 마치며

프록시는 새로운 해결책이라기보단 새로운 문제를 해결하는 기법에 가깝습니다.

그 중 흥미로운 점은 프록시의 존재를 통해 여러가지 문제들이 해결된다는 것인데요

1. API 객체를 수정하지 않기 위해 컨슈머 코드에 의존하는 대신 프록시를 사용하기

소비 코드가 객체에 대해 갖는 접근을 제어할 수 있어진다.

2. 프록시를 사용하여 구현 코드와 계측 코드를 분리하기

계측코드 ? -> 객체 사용, 성능 등의 패턴을 결정하는 데 도움이 되도록 설계된 코드

프록시를 사용하는 것을 통해 계측 계층을 추가할 수 있고 따라서 객체의 구현 코드를 깔끔하게 유지할 수 있다.



# 레퍼런스

https://patterns-dev-kr.github.io/design-patterns/proxy-pattern/

https://refactoring.guru/ko/design-patterns/proxy
