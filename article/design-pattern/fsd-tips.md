
# fsd honey tips

최근 저는 Feature-Sliced Design을 여러 프로젝트에 적용해보기도하고, 테오의 스프린트에서는 fsd 경험이 없는 팀원들에게 fsd를 온보딩시키고 신규 프로젝트에 사용한 경험이 있습니다.

약 두달정도의 시간동안 fsd를 탐구해보고 사용한 것 같은데요 이 시간동안 얻었던 인사이트를 공유합니다.

## 명칭

[Feature-Sliced Design 브랜드북](https://feature-sliced.design/docs/branding)에 따르면

Feature-Sliced Design이 올바른 명칭입니다.


## 1/3은 명확하다.

FSD의 기본 멘탈모델을 나열하면 다음과 같습니다.

- app

- pages

- widgets

- fetures

- entities

- shared

이 중 pages, entities, features, widgets는 프로젝트의 구조에 따라 적용이 어려운 프로젝트가 있을 수 있습니다.

그러나 app과 shared는 상당히 명확하면서 대부분의 프로젝트에 적용할 수 있는 개념이며

이 형태로 구분하는 것은 새로운 표준이 되어도 상관없지않을까..? 같은 생각이 듭니다.

app 계층에는 프로젝트에 전역적으로 영향을 주는 코드를 배치하고 shared에는 모든 코드들이 잠재적으로 의존해야하는 코드를 배치한다.

라는 발상이 매우 명확하며 shared 계층에 손을 대는 것에 대한 책임감을 가지게 합니다.


## 왜 나머지는 불명확한가?

도메인에 따라서 feature 단위로 슬라이싱하는게 어려운 도메인이 있을 수 있습니다.

특히 특정 도메인 모델을 중심으로 돌아가는 프로젝트일수록 그 경향이 뚜렷한데요

거의 모든 기능이 해당 도메인 모델을 위주로 돌아가게 되는 프로젝트의 경우에는 기능 분할이라는 개념 자체가 안먹히기도합니다.

또 일반적으로 발생하는 문제중에 하나인 문제가 있는데요 특정 pages가 여러곳에서 공유되어야하는 경우도 상당히 난감한 면이 있습니다.

예를 들면 로그인이 필요한 기능이 들어가있는 페이지에 접근하는 경우 로그인 페이지를 띄워달라. 라는 요구사항은 매우 일반적입니다.

그러나 이를 위해서는 로그인 페이지의 계층을 위로 끌어올려서 공유 페이지라는 개념을 만들거나

혹은 일부분의 규칙을 어기거나 아니면 app 계층에서 하이오더컴포넌트들을 만들고 하이오더컴포넌트로 관리해야합니다.


## entities와 features간의 거리가 멀다 (colocation 이슈)

이부분이 불편한 포인트는 entities에서 데이터를 읽어오지만 그 데이터를 변경하는 작업의 경우에는 관심사가 유저의 행동에 있기때문에 features로 분류된다는 것입니다.

따라서 이러한 경우 두 기능이 밀접하게 관련이 있음에도 불구하고 코로케이션을 적용할 수가 없다는 문제가 발생하게됩니다.

이부분은 어떻게 해결해야 좋을지 고민중입니다.

## nextjs 한정 -> pages 계층과 nextjs 폴더라우팅 간의 거리가 멀다

pages 계층을 두는 걸 통해 next.js와 같은 프레임워크를 세부사항으로 치부하며 유연한 구조를 가질 수 있게되었지만

반대급부로 page를 만들떄마다 nextjs의 파일구조 라우팅시스템에 우리의 pages 계층을 바인딩해주어야한다는 오버헤드가 생깁니다.

-> 이부분은 hygen을 통해 자동화했고 만족스럽네요

## 배럴 익스포트를 적극적으로 활용하는 문제

배럴 익스포트는 깔끔한 import 구문을 제공해주며 FSD에서는 해당 계층이 외부 계층에 노출시킬 api들을 나타내기때문에

그 중요성이 매우 큰 기법임에도 불구하고 성능이슈, 트리쉐이킹이슈, 동작방식의 이슈가 존재합니다.

(관심있으신분들은 아티클 스터디 2기 지현님이 배럴 익스포트 다룬게 있으니 깃허브에서 확인해보세요)

저는 import 구문이 쪼끔 길어지더라도 최대한 작은 단위로 index.ts를 두는 걸 통해 문제를 완화하고 있습니다.

## 파일이름을 잘 정하는게 중요하다

fsd를 적용하다보면 코로케이션은 상대적으로 약해지는 모순이 있습니다.

기능별로 쪼개서 관리하자는 발상이 담기긴 했지만 기본적으로 각 계층들을 기준으로 슬라이싱해서 관리하기 때문이에요

그래서 직접 눈으로 파일을 찾아다니는거보다 효율적으로 검색할 수 있는 파일이름을 만드는게 상당히 중요했습니다.

저같은 경우에는 
```tsx
`${해당 기능의 폴더이름}.${해당 기능이 표현하는 바 api|type 등등}.${ts | tsx}`
```
와 같은 형태로 정의하는 편입니다.


# 그럼에도 쓸만하다.

entities, features, widgets을 나누는것이 비효율적이거나 구조상 잘 안맞을 수는 있습니다.

이런 경우에는 계층을 과감하게 줄이고 한 기능을 하나의 피쳐로 묶어서 취급하는 것도 괜찮을 것 같습니다.

그렇게한다면 폴더구조는 이런 느낌이 될 것 같아요

- app

- slice
  - 기능 A
  - 기능 B
  - 기능 C
- shared

개인적으로는 app, shared는 어느곳에나 적용가능한 아이디어라고 생각이 들어요

app, shared 부분은 익숙해지면 굉장히 코드 관리하는게 명확해지는 것 같습니다.

