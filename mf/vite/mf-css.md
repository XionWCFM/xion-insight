마이크로프론트엔드는 사용자에게 더 많은 리소스를 요구하게 될 가능성이 높습니다.

예컨대 모든 마이크로서비스가 자기만의 리액트 버전을 가지고 리액트를 갖고온다면 이론적으로 마이크로프론트엔드 프로젝트는 네트워크 통신량이 N이 되어버리겠지요..

이것은 CSS에서도 마찬가지인데 CSS 쪽은 조금 더 까다롭습니다.

결국 리모트 모듈들은 하나의 브라우저에서 실행되는데 CSS는 캐스케이딩되고 나중에 들어오는 스타일이 이전 스타일을 덮어 쓰기 때문입니다.

서비스가 많아질수록 중복되는 css가 많아지며 이것을 해결할 방법도 뾰족하지않습니다.

해결방법은 몇가지가 있는데요


1. 테일윈드를 호스트나 루트에서 한번만 부르면 된다.

트레이드오프가 명확합니다. 호스트를 빌드할 때 리모트들의 스타일을 읽어서 빌드한다면 리모트와 호스트간의 의존성이 생겨버립니다.

그렇다고 모든 css를 빌드하자니 그건 그것대로 입맛이 조금 쓰죠

2. css-in-js를 쓴다.

대부분 css-in-js는 클래스를 동적으로 생성하며 네이밍이 겹치지않도록 난독화를 수행해줍니다.

하지만 이 방법 역시 만족스럽지 않습니다. css-in-js는 성능을 희생하기도 하니까요


3. prefix를 붙인다.

```
module.exports = {
  prefix: "custom1-",
}
```

빌드할때 프리픽스를 사용할 수 있습니다.


4. 쉐도우돔을 쓴다.

ㅇ ㅅㅇ... 공유 컴포넌트를 사용하기 위해서는 공유 컴포넌트의 스타일을 해당 리모트에서 모두 갖고있어야합니다. 



5. postcss prefix

postcss를 이용해서 개발할때는 프리픽스 신경안쓰고 개발하고 빌드할때만 프리픽스를 붙여줍니다.


6. 여기까지 닿고나니 디자인 시스템에서 자잘한 css 조작을 props 형태로 블랙박스화해서 제공해주는 것이 MFA에서 좋은 해결책인 것 같다.라는 생각을 했습니다.

사실상 1번의 테일윈드를 호스트에서 부르고 전부 빌드해둔다와 비슷한 해결책입니다만 디자인 시스템에서는 꼭 쓰는것만 빌드를 해둘 수 있으니 조금 더 효율적일것이고 리모트에서 디자인 시스템의 프랍만 이용해서 조작한다면 css 중복 문제도 발생하지 않습니다.

